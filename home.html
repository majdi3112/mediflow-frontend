<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="static/images/icon.png" type="image/png" sizes="168x168">
  <title>Consultium AI - Professional Medical Documentation</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=Manrope:wght@600;700;800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
 <style>
    /* Custom styles */
    * { font-family: 'Inter', 'Plus Jakarta Sans', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
    h1, h2, h3, h4 { font-family: 'Manrope', 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; font-weight: 800; letter-spacing: -0.015em; }
    
    /* Prevent horizontal layout shift when tabs change height */
    html { overflow-y: scroll; scrollbar-gutter: stable both-edges; }
    :root {
      /* Soft, airy shadow like the login card */
      --shadow-soft: 0 24px 48px rgba(17, 24, 39, 0.08), 0 8px 16px rgba(17, 24, 39, 0.04);
      --shadow-soft-hover: 0 32px 64px rgba(17, 24, 39, 0.12), 0 12px 24px rgba(17, 24, 39, 0.06);
    }
    
    /* Generic soft card shadow */
    .card-soft { box-shadow: var(--shadow-soft); transition: box-shadow .3s ease, transform .3s ease; }
    .card-soft:hover { box-shadow: var(--shadow-soft-hover); }

    /* Subtle white highlight for headings and text */
    .text-white-highlight-strong {
      font-weight: 900; /* extra dik */
      text-shadow: 0 1px 0 rgba(255,255,255,1), 0 0 12px rgba(255,255,255,0.45);
    }
    .text-white-highlight {
      font-weight: 600;
      text-shadow: 0 1px 0 rgba(255,255,255,0.9), 0 0 6px rgba(255,255,255,0.30);
    }
    
    /* Soft Windows-like blue gradient background */
    body {
      background:
        radial-gradient(900px 500px at 15% 20%, rgba(147, 197, 253, 0.28) 0%, rgba(147, 197, 253, 0.00) 60%),
        radial-gradient(900px 520px at 85% 80%, rgba(125, 211, 252, 0.26) 0%, rgba(125, 211, 252, 0.00) 60%),
        linear-gradient(180deg, #fbfdff 0%, #eef7ff 100%);
      background-attachment: fixed;
    }
    
    /* Loading overlay */
    #loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      backdrop-filter: blur(4px);
    }
    
    .spinner {
      border: 3px solid #e5e7eb;
      border-top-color: #3b82f6;
      border-radius: 50%;
      width: 2.5rem;
      height: 2.5rem;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Professional gradient backgrounds */
    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .blue-gradient {
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
    }
    
    /* Card hover effects */
    .hover-lift {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .hover-lift:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-soft-hover);
    }
    
    /* Feature cards */
    .feature-card {
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: var(--shadow-soft);
      border: 1px solid #e5e7eb;
      transition: all 0.3s ease;
    }
    
    .feature-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-soft-hover);
    }
    
    /* Coming Soon cards */
    .coming-soon-card {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: var(--shadow-soft);
      border: 2px dashed #cbd5e1;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .coming-soon-card:hover {
      transform: translateY(-2px);
      border-color: #94a3b8;
      box-shadow: var(--shadow-soft-hover);
    }
    
    .coming-soon-badge {
      position: absolute;
      top: 10px;
      right: -25px;
      background: linear-gradient(45deg, #3b82f6, #06b6d4);
      color: white;
      padding: 6px 35px;
      font-size: 0.7rem;
      font-weight: 700;
      transform: rotate(35deg);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      letter-spacing: 0.5px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    
    .coming-soon-content {
      filter: grayscale(0.3);
      opacity: 0.8;
    }
    
    .pulse-glow {
      animation: pulse-glow 2s ease-in-out infinite alternate;
    }
    
    @keyframes pulse-glow {
      from {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      }
      to {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 0 20px rgba(59, 130, 246, 0.3);
      }
    }
    
    .lamp-pulse {
      animation: lamp-pulse 1.5s ease-in-out infinite alternate;
    }
    
    @keyframes lamp-pulse {
      from {
        box-shadow: 0 0 5px rgba(251, 191, 36, 0.5);
      }
      to {
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
      }
    }
    

    
    /* SOEP sections */
    .soep-section {
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-soft);
      border: 1px solid #e5e7eb;
    }
    
    /* Recording overlay */
    .recording-overlay {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(8px);
    }
    
    /* Live transcription styling */
    #live-transcription-display {
      height: 300px;
      overflow-y: auto;
      overflow-x: hidden;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border: 2px solid #0ea5e9;
      border-radius: 1rem;
      padding: 1rem;
      font-family: 'Plus Jakarta Sans', Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      animation: live-pulse 2s ease-in-out infinite;
      transition: all 0.3s ease;
      scroll-behavior: smooth;
      resize: none; /* Disable manual resizing */
    }

    /* Auto-expanding behavior */
    #live-transcription-display.expanding {
      height: 300px !important;
    }

    /* Better scrollbar for transcription */
    #live-transcription-display::-webkit-scrollbar {
      width: 8px;
    }
    
    #live-transcription-display::-webkit-scrollbar-track {
      background: rgba(59, 130, 246, 0.1);
      border-radius: 4px;
    }
    
    #live-transcription-display::-webkit-scrollbar-thumb {
      background: rgba(59, 130, 246, 0.5);
      border-radius: 4px;
    }
    
    #live-transcription-display::-webkit-scrollbar-thumb:hover {
      background: rgba(59, 130, 246, 0.7);
    }

    @keyframes live-pulse {
      0%, 100% { border-color: #0ea5e9; }
      50% { border-color: #06b6d4; }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .live-transcript-text {
      color: #0c4a6e;
      font-size: 1.1rem;
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(255,255,255,0.8);
    }

    .typing-indicator {
      color: #0891b2;
      font-style: italic;
      opacity: 0.7;
    }
    
    /* Navigation tabs */
    .nav-tab {
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
         .nav-tab.active {
       background: linear-gradient(135deg, #3b82f6 0%, #06b6d4 100%);
       color: white;
     }
    
    .nav-tab:not(.active) {
      background: #f8fafc;
      color: #64748b;
    }
    
    .nav-tab:not(.active):hover {
      background: #e2e8f0;
      color: #475569;
    }
    
    /* Custom scrollbar */
    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-track {
      background: #f1f5f9;
      border-radius: 3px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    
    /* Tolk speaking visualizer */
    #tolk-visual-wrapper { position: relative; }
    #tolk-visual-wrapper { --amp: 0; }
    .speak-ring { position: absolute; inset: -10px; border-radius: 9999px; transform-origin: center; pointer-events: none; opacity: 0; transition: opacity 0.3s ease, transform 0.2s ease; }
    .speak-ring.r1 { background: radial-gradient(closest-side, rgba(59,130,246,0.35), transparent 70%); filter: blur(6px); }
    .speak-ring.r2 { background: radial-gradient(closest-side, rgba(6,182,212,0.30), transparent 75%); filter: blur(12px); }
    #tolk-visual-wrapper.speaking .speak-ring { opacity: 1; transform: scale(calc(1 + var(--amp) * 0.6)); }

    /* Button breathing glow while AI speaks */
    #tolk-record-btn.ai-speaking { animation: ring-breathe 1.4s ease-in-out infinite; }
    @keyframes ring-breathe {
      0%, 100% { box-shadow: 0 0 0 2px rgba(59,130,246,0.35), 0 0 0 12px rgba(6,182,212,0.15); }
      50% { box-shadow: 0 0 0 8px rgba(59,130,246,0.45), 0 0 0 20px rgba(6,182,212,0.20); }
    }

    /* Mic waves inside button */
    #tolk-record-btn svg .mic-wave { opacity: 0.55; }
    #tolk-record-btn.ai-speaking svg .mic-wave { animation: wave-pulse 1.6s ease-in-out infinite; }
    #tolk-record-btn.ai-speaking svg .mic-wave.wave2 { animation-delay: .25s; }
    @keyframes wave-pulse { 0%,100% { opacity: .35; } 50% { opacity: 1; } }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <!-- Loading overlay -->
  <div id="loading-overlay">
    <div class="text-center">
      <div class="spinner mx-auto mb-4"></div>
      <p class="text-gray-600">Verwerken...</p>
    </div>
  </div>

  <!-- Header -->
  <header class="bg-white shadow-sm border-b border-gray-200">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center h-16">
    <div class="flex items-center space-x-3">
          <img src="static/images/logo.png" alt="Consultium AI" class="h-32 w-auto">
    </div>
        
                 <!-- Navigation -->
         <nav class="hidden md:flex space-x-8">
           <button class="nav-tab active" data-tab="dashboard">Dashboard</button>
           <button class="nav-tab" data-tab="soep">SOEP Verslag</button>
           <button class="nav-tab" data-tab="tolk">Live Tolk</button>
         </nav>
        
        <!-- Profile -->
    <div class="relative">
          <button onclick="toggleMenu()" class="flex items-center space-x-2 text-gray-700 hover:text-gray-900">
            <img src="static/images/default.png" alt="Profiel" class="w-10 h-10 rounded-full border border-gray-300 cursor-pointer">
          </button>
          <div id="dropdown-menu" class="hidden absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg z-50 border border-gray-200">
            <a href="#" class="block px-4 py-2 text-gray-700 hover:bg-gray-50">Account Instellingen</a>
            <a href="index.html" class="block px-4 py-2 text-gray-700 hover:bg-gray-50">Uitloggen</a>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Recording Overlay -->
  <div id="recording-overlay" class="fixed inset-0 recording-overlay hidden z-50 flex flex-col items-center justify-center">
    <button id="cancel-recording-btn" class="absolute top-6 right-6 text-3xl text-gray-500 hover:text-gray-700 transition-colors">&times;</button>
    
    <div class="text-center mb-8">
      <h2 class="text-3xl font-bold text-gray-900 mb-2">Live Transcriptie</h2>
      <p class="text-gray-600">AI identificeert automatisch Arts & Pati√´nt tijdens het gesprek</p>
    </div>
    
    <!-- Live Transcriptie Display (vervangt waveform) -->
    <div class="w-full max-w-4xl mb-8">
      <div id="live-transcription-display" class="custom-scrollbar">
        <div class="live-transcript-text" id="live-transcript-content">
          <span class="typing-indicator">üé§ Begin met spreken...</span>
        </div>
      </div>
    </div>
    
    <div class="flex gap-4">
      <button id="soep-recording-btn" class="px-8 py-4 blue-gradient text-white text-xl font-semibold rounded-full shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105">
        SOEP
      </button>
    </div>
  </div>

  <!-- Main Content -->
  <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    
    <!-- Dashboard Tab -->
    <div id="dashboard-tab" class="tab-content">
             <!-- Hero Section -->
       <div class="blue-gradient rounded-2xl p-8 text-white mb-8">
        <div class="max-w-3xl">
          <h1 class="text-4xl font-bold mb-4">Welkom bij Consultium AI</h1>
          <p class="text-xl mb-6 opacity-90">De slimme assistent die je tijd geeft voor wat er √©cht toe doet; de patient. Bespaar tijd, houd focus.</p>
                                <div class="flex flex-wrap gap-4">
             <button onclick="switchTab('soep')" class="px-6 py-3 bg-white text-blue-600 rounded-lg font-semibold hover:bg-gray-50 transition-colors">
               Start SOEP Verslag
             </button>
           </div>
        </div>
      </div>

             <!-- Feature Cards -->
       <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
         <div class="feature-card hover-lift">
           <div class="flex items-center mb-4">
             <div class="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center mr-4">
               <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
               </svg>
             </div>
             <h3 class="text-xl font-semibold text-gray-900">SOEP Verslag</h3>
           </div>
           <p class="text-gray-600 mb-4">Automatische structurering volgens NHG-richtlijnen binnen seconden.</p>
           <button onclick="switchTab('soep')" class="text-blue-600 font-medium hover:text-cyan-600">Probeer nu ‚Üí</button>
         </div>

         <div class="feature-card hover-lift">
           <div class="flex items-center mb-4">
             <div class="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center mr-4">
               <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
               </svg>
             </div>
             <h3 class="text-xl font-semibold text-gray-900">Live Opname</h3>
           </div>
           <p class="text-gray-600 mb-4">Real-time transcriptie tijdens het consult.</p>
           <button onclick="switchTab('soep')" class="text-green-600 font-medium hover:text-green-700">Start opname ‚Üí</button>
         </div>



        <div class="feature-card hover-lift relative">
          <div class="absolute inset-0 rounded-2xl bg-black/10 backdrop-blur-sm flex items-center justify-center z-10 select-none cursor-not-allowed">
            <div class="px-4 py-1.5 rounded-full bg-white/90 text-slate-900 text-sm font-semibold shadow ring-1 ring-white/60">
              Beschikbaar vanaf november
            </div>
          </div>
           <div class="flex items-center mb-4">
             <div class="w-12 h-12 bg-orange-100 rounded-lg flex items-center justify-center mr-4">
               <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m10.5 21 5.25-11.25L21 21m-9-3h7.5M3 5.621a48.474 48.474 0 0 1 6-.371m0 0c1.12 0 2.233.038 3.334.114M9 5.25V3m3.334 2.364C11.176 10.658 7.69 15.08 3 17.502m9.334-12.138c.896.061 1.764.147 2.598.266m-2.598-.266C15.176 4.904 18.69.482 23 2.904"></path>
               </svg>
             </div>
             <h3 class="text-xl font-semibold text-gray-900">Live Tolk</h3>
           </div>
           <p class="text-gray-600 mb-4">Speech-to-speech vertaling tussen dokter en pati√´nt tijdens het consult.</p>
          <button disabled aria-disabled="true" class="text-orange-400 font-medium cursor-not-allowed opacity-60">Start vertaling ‚Üí</button>
         </div>

         <!-- Coming Soon Cards -->
         <div class="coming-soon-card pulse-glow" style="animation-delay: 0.5s;">
           <div class="coming-soon-badge">BINNENKORT</div>
           <div class="coming-soon-content">
             <div class="flex items-center mb-4">
               <div class="w-12 h-12 bg-red-100 rounded-lg flex items-center justify-center mr-4 relative">
                 <svg class="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                   <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 3.104v5.714a2.25 2.25 0 01-.659 1.591L5 14.5M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 014.5 0m0 0v5.714c0 .597.237 1.17.659 1.591L19.8 14.5M14.25 3.104c.251.023.501.05.75.082M19.8 14.5l-2.6 2.6a2.25 2.25 0 01-3.182 0l-2.6-2.6M19.8 14.5V16a2.25 2.25 0 01-2.25 2.25h-8.1A2.25 2.25 0 017.2 16v-1.5m12.6 0a2.25 2.25 0 012.25 2.25V19a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 19v-2.75"></path>
                 </svg>
                 <!-- Lamp Alert Icon -->
                 <div class="absolute -top-1 -right-1 w-4 h-4 bg-yellow-400 rounded-full flex items-center justify-center lamp-pulse">
                   <svg class="w-2.5 h-2.5 text-yellow-800" fill="currentColor" viewBox="0 0 20 20">
                     <path d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"/>
                   </svg>
                 </div>
               </div>
               <h3 class="text-xl font-semibold text-gray-700">Smart DD's</h3>
             </div>
             <p class="text-gray-500 mb-4">Met slimme DD-voorstellen denkt de AI actief met je mee en versterkt jouw klinisch inzicht.</p>
             <div class="flex items-center text-gray-400 font-medium cursor-not-allowed">
               <svg class="w-4 h-4 mr-2 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                 <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
               </svg>
               Wordt ontwikkeld...
             </div>
           </div>
         </div>

         <div class="coming-soon-card pulse-glow" style="animation-delay: 1.5s;">
           <div class="coming-soon-badge">BINNENKORT</div>
           <div class="coming-soon-content">
             <div class="flex items-center mb-4">
               <div class="w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center mr-4 relative">
                 <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                   <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                 </svg>
                 <!-- Lamp Alert Icon -->
                 <div class="absolute -top-1 -right-1 w-4 h-4 bg-yellow-400 rounded-full flex items-center justify-center lamp-pulse">
                   <svg class="w-2.5 h-2.5 text-yellow-800" fill="currentColor" viewBox="0 0 20 20">
                     <path d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"/>
                   </svg>
                 </div>
               </div>
               <h3 class="text-xl font-semibold text-gray-700">AI Chat Assistant</h3>
             </div>
             <p class="text-gray-500 mb-4">Stel medische vragen en krijg directe, gevalideerde antwoorden.</p>
             <div class="flex items-center text-gray-400 font-medium cursor-not-allowed">
               <svg class="w-4 h-4 mr-2 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                 <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
               </svg>
               Wordt ontwikkeld...
             </div>
           </div>
         </div>         
         <div class="coming-soon-card pulse-glow" style="animation-delay: 1s;">
           <div class="coming-soon-badge">BINNENKORT</div>
           <div class="coming-soon-content">
             <div class="flex items-center mb-4">
               <div class="w-12 h-12 bg-indigo-100 rounded-lg flex items-center justify-center mr-4 relative">
                 <svg class="w-6 h-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                   <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z"></path>
                 </svg>
                 <!-- Lamp Alert Icon -->
                 <div class="absolute -top-1 -right-1 w-4 h-4 bg-yellow-400 rounded-full flex items-center justify-center lamp-pulse">
                   <svg class="w-2.5 h-2.5 text-yellow-800" fill="currentColor" viewBox="0 0 20 20">
                     <path d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"/>
                   </svg>
                 </div>
               </div>
               <h3 class="text-xl font-semibold text-gray-700">Smart Alerts</h3>
             </div>
             <p class="text-gray-500 mb-4">Kleurcodes geven urgentie aan en waarschuwen direct bij fout beleid of medicatie met een waarschuwingsdriehoek.</p>
             <div class="flex items-center text-gray-400 font-medium cursor-not-allowed">
               <svg class="w-4 h-4 mr-2 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                 <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
               </svg>
               Wordt ontwikkeld...
             </div>
           </div>
         </div>
       </div>

      
    </div>

    <!-- SOEP Tab -->
    <div id="soep-tab" class="tab-content hidden">
      <div class="mb-8">
        <h2 class="text-3xl font-bold text-gray-900 mb-2 text-white-highlight-strong">SOEP Verslag</h2>
        <p class="text-gray-600 text-white-highlight">Voer uw consultnotities in of gebruik spraakopname met real-time transcriptie</p>
      </div>

      <!-- Input Section -->
      <div class="bg-white rounded-2xl p-6 border border-gray-200 mb-8 card-soft">
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Consultnotities</label>
          <textarea 
            id="text-input" 
            placeholder="Voer hier uw consultnotities in of gebruik de opnamefunctie met live transcriptie..."
            class="w-full p-4 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            rows="6"
          ></textarea>
        </div>
        
        <div class="flex flex-wrap gap-4">
          <button id="whisper-btn" class="px-6 py-3 blue-gradient text-white rounded-lg font-semibold hover:shadow-lg transition-all duration-300">
            Start Opname
          </button>
          <button id="generate-soep" class="px-6 py-3 bg-gray-100 text-gray-700 rounded-lg font-semibold hover:bg-gray-200 transition-colors">
            SOEP
          </button>
        </div>
      </div>

      <!-- SOEP Results -->
      <div id="verslag-container" class="hidden">
        <h3 class="text-2xl font-bold text-gray-900 mb-6">SOEP Verslag</h3>
        <div class="grid gap-6">
          <div id="s-section" class="soep-section">
            <div class="flex justify-between items-center mb-4">
              <h4 class="text-xl font-semibold text-gray-900">S - Subjectief</h4>
              <button onclick="copySection('s-content')" class="px-3 py-1 bg-gray-100 text-gray-600 rounded-md hover:bg-gray-200 transition-colors">
                üìã Kopi√´ren
              </button>
            </div>
            <div id="s-content" class="text-gray-700 leading-relaxed"></div>
          </div>

          <div id="o-section" class="soep-section">
            <div class="flex justify-between items-center mb-4">
              <h4 class="text-xl font-semibold text-gray-900">O - Objectief</h4>
              <button onclick="copySection('o-content')" class="px-3 py-1 bg-gray-100 text-gray-600 rounded-md hover:bg-gray-200 transition-colors">
                üìã Kopi√´ren
              </button>
            </div>
            <div id="o-content" class="text-gray-700 leading-relaxed"></div>
          </div>

          <div id="e-section" class="soep-section">
            <div class="flex justify-between items-center mb-4">
              <h4 class="text-xl font-semibold text-gray-900">E - Evaluatie</h4>
              <button onclick="copySection('e-content')" class="px-3 py-1 bg-gray-100 text-gray-600 rounded-md hover:bg-gray-200 transition-colors">
                üìã Kopi√´ren
              </button>
            </div>
            <div id="e-content" class="text-gray-700 leading-relaxed"></div>
          </div>

          <div id="p-section" class="soep-section">
            <div class="flex justify-between items-center mb-4">
              <h4 class="text-xl font-semibold text-gray-900">P - Plan</h4>
              <button onclick="copySection('p-content')" class="px-3 py-1 bg-gray-100 text-gray-600 rounded-md hover:bg-gray-200 transition-colors">
                üìã Kopi√´ren
              </button>
            </div>
            <div id="p-content" class="text-gray-700 leading-relaxed"></div>
          </div>
        </div>
      </div>
    </div>



     <!-- Live Tolk Tab (minimal) -->
      <div id="tolk-tab" class="tab-content hidden">
      <div class="mb-8">
        <h2 class="text-4xl font-bold text-gray-900 tracking-tight mb-2 text-white-highlight-strong">Live Tolk</h2>
        <p class="text-gray-600 text-base text-white-highlight">Realtime speech‚Äëto‚Äëspeech vertaling tussen arts en pati√´nt. AI vertaalt en kan een SOEP‚Äëverslag genereren.</p>
       </div>

       <div class="bg-white rounded-2xl p-6 border border-gray-200 mb-8 card-soft">
          <h3 class="text-xl font-semibold text-gray-900 mb-4">Taal Instellingen</h3>
          <div class="grid md:grid-cols-2 gap-6">
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">Taal 1 (arts)</label>
              <select id="language-1" class="w-full p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-200 bg-gray-50 hover:bg-white transition">
               <option value="nl">Nederlands</option>
               <option value="en">Engels</option>
               <option value="fr">Frans</option>
               <option value="ar">Arabisch</option>
               <option value="de">Duits</option>
               <option value="es">Spaans</option>
             </select>
           </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">Taal 2 (pati√´nt)</label>
              <select id="language-2" class="w-full p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-200 bg-gray-50 hover:bg-white transition">
               <option value="nl">Nederlands</option>
               <option value="en">Engels</option>
               <option value="fr">Frans</option>
               <option value="ar">Arabisch</option>
               <option value="de">Duits</option>
               <option value="es">Spaans</option>
             </select>
           </div>
         </div>
       </div>

      <div class="bg-white rounded-2xl p-12 border border-gray-200 mb-10 text-center card-soft relative">
          <div class="absolute inset-0 rounded-2xl bg-black/10 backdrop-blur-sm flex items-center justify-center z-20 select-none cursor-not-allowed">
            <div class="px-5 py-2 rounded-full bg-white/90 text-slate-900 text-base font-semibold shadow ring-1 ring-white/60">
              Beschikbaar vanaf november
            </div>
          </div>
          <div id="tolk-visual-wrapper" class="relative inline-block mx-auto">
            <span class="speak-ring r1"></span>
            <span class="speak-ring r2"></span>
            <button id="tolk-record-btn" aria-label="Start/stop tolk" class="w-32 h-32 rounded-full bg-gradient-to-r from-blue-600 to-cyan-600 hover:shadow-lg transition-all duration-300 transform hover:scale-105 flex items-center justify-center">
              <svg class="w-14 h-14" viewBox="0 0 64 64" fill="none" stroke="white" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <!-- left waves -->
                <path class="mic-wave wave1" stroke-width="2.2" d="M16 22c-4 5-4 15 0 20"/>
                <path class="mic-wave wave2" stroke-width="2.2" d="M12 18c-6 7-6 21 0 28"/>
                <!-- mic body -->
                <path stroke-width="2.4" d="M38 32v-8a6 6 0 10-12 0v8a6 6 0 1012 0z"/>
                <path stroke-width="2.2" d="M20 31v1a12 12 0 0024 0v-1"/>
                <path stroke-width="2.2" d="M32 44v8M26 52h12"/>
                <!-- right waves -->
                <path class="mic-wave wave1" stroke-width="2.2" d="M48 22c4 5 4 15 0 20"/>
                <path class="mic-wave wave2" stroke-width="2.2" d="M52 18c6 7 6 21 0 28"/>
              </svg>
            </button>
          </div>
          <div id="tolk-status" class="px-4 py-2 bg-gray-50 border border-gray-200 text-gray-700 rounded-full text-sm block w-fit mx-auto mt-5 mb-6">Klaar voor spraak‚Äënaar‚Äëspraak</div>
          <canvas id="tolk-visualizer" class="w-full max-w-xl h-20 mx-auto mt-2"></canvas>
         <p class="text-sm text-gray-500 mt-4">Klik om spraak‚Äënaar‚Äëspraak vertaling te starten/stoppen</p>
         <audio id="tolk-remote-audio" autoplay class="hidden"></audio>
        <div class="mt-6 flex items-center justify-center">
          <button id="tolk-soep-btn" class="px-6 py-3 blue-gradient text-white rounded-lg font-semibold disabled:opacity-50" disabled>
            SOEP
          </button>
        </div>
       </div>
    </div>

  <!-- Scripts -->
  <script>
    // Hard-coded API base for ngrok deployment
    const API_BASE = 'https://ebf0676e069d.ngrok-free.app';
    const RT_SID = (crypto?.randomUUID && crypto.randomUUID()) || String(Date.now());
    const endpoints = {
      generateSoep: API_BASE + '/generate-soep',
      realtimeTranscribe: API_BASE + '/realtime-transcribe?sid=' + encodeURIComponent(RT_SID),
      transcribeAudio: API_BASE + '/transcribe-audio',
      intelligentTranslate: API_BASE + '/intelligent-translate'
    };
    let realtimeTranscribeUrl = endpoints.realtimeTranscribe;
    // Tab switching functionality
    function switchTab(tabName) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.add('hidden');
      });
      
      // Remove active class from all nav tabs
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show selected tab content
      document.getElementById(tabName + '-tab').classList.remove('hidden');
      
      // Add active class to selected nav tab
      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    }

    // Navigation tab click handlers
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.getAttribute('data-tab');
        switchTab(tabName);
      });
    });

    // Profile dropdown toggle
    function toggleMenu() {
      document.getElementById('dropdown-menu').classList.toggle('hidden');
    }

    // Close dropdown when clicking outside
    window.addEventListener('click', e => {
      if (!e.target.closest('button') && !e.target.closest('#dropdown-menu')) {
        document.getElementById('dropdown-menu').classList.add('hidden');
      }
    });



    

    // SOEP Generation functionality
  async function generateSOEP() {
    const textareaEl = document.getElementById('text-input');
    let promptText = (textareaEl.value || '').trim();
    // Fallback: gebruik live transcriptie wanneer het veld leeg is
    if (!promptText && typeof liveTranscriptionText === 'string' && liveTranscriptionText.trim()) {
      promptText = liveTranscriptionText.trim();
      textareaEl.value = promptText;
    }
    if (!promptText) {
      alert('Voer eerst tekst in of maak een opname.');
      return;
    }

      showLoading(true);

    try {
        const response = await fetch(endpoints.generateSoep, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt: promptText })
      });
        
        const data = await response.json();
        
        if (data.error) {
          throw new Error(data.error);
        }
        
        // Populate SOEP sections
        ['s', 'o', 'e', 'p'].forEach(section => {
          const content = data[section] || 'Geen gegevens beschikbaar';
          document.getElementById(`${section}-content`).innerHTML = formatContent(content);
        });
        
        // Show results and switch to SOEP tab
      document.getElementById('verslag-container').classList.remove('hidden');
        
        // Smooth scroll to results
        setTimeout(() => {
          document.getElementById('verslag-container').scrollIntoView({ 
            behavior: 'smooth', 
            block: 'start' 
          });
        }, 100);
        
      } catch (error) {
        console.error('Error generating SOEP:', error);
        alert('Er is een fout opgetreden bij het genereren van het SOEP-verslag. Probeer het opnieuw.');
    } finally {
        showLoading(false);
      }
    }

    function formatContent(content) {
      // Format bullet points and structure content nicely
      return content
        .replace(/\n/g, '<br>')
        .replace(/‚Ä¢\s*/g, '<br>‚Ä¢ ')
        .replace(/^<br>/, '');
    }

    function copySection(sectionId) {
      const element = document.getElementById(sectionId);
      const text = element.innerText || element.textContent;
      
      navigator.clipboard.writeText(text).then(() => {
        // Visual feedback
        const button = element.parentElement.querySelector('button');
        const originalText = button.textContent;
        button.textContent = '‚úì Gekopieerd';
        button.classList.add('bg-green-100', 'text-green-600');
        
        setTimeout(() => {
          button.textContent = originalText;
          button.classList.remove('bg-green-100', 'text-green-600');
        }, 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        alert('Kopi√´ren mislukt. Probeer het opnieuw.');
      });
    }

    // üöÄ NEW: Enhanced Recording functionality with REAL-TIME transcription
    // Dual recorders: one for realtime streaming, one for batch-quality processing
    let mediaRecorderRealtime = null;
    let mediaRecorderBatch = null;
    let audioStream = null;
    let batchChunks = [];
    let realtimeChunks = [];
    let realtimeInterval = null;
    let liveTranscriptionText = '';
    let lastSpeakerText = '';
    // No special WebM header handling for realtime chunks
    let isSendingRealtime = false;

    // WAV-based realtime capture (PCM ring buffer at 16kHz)
    let audioContext = null;
    let sourceNode = null;
    let processorNode = null;
    let pcmRingBuffer = [];
    let pcmFullBuffer = [];
    let pcmSampleRate = 48000;
    const TARGET_SAMPLE_RATE = 16000;
    const WINDOW_SECONDS = 20; // ~last 20 chunks (1.5s tick)
    const MAX_BUFFER_SECONDS = 20;

    function downsampleTo16k(float32, originalRate) {
      if (originalRate === TARGET_SAMPLE_RATE) return float32;
      const ratio = originalRate / TARGET_SAMPLE_RATE;
      const newLen = Math.floor(float32.length / ratio);
      const result = new Float32Array(newLen);
      let offsetResult = 0, offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < float32.length; i++) {
          accum += float32[i];
          count++;
        }
        result[offsetResult] = count ? (accum / count) : 0;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function floatTo16BitPCM(float32) {
      const buf = new ArrayBuffer(float32.length * 2);
      const view = new DataView(buf);
      let offset = 0;
      for (let i = 0; i < float32.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return view;
    }

    function encodeWAV(int16View, numChannels = 1, sampleRate = TARGET_SAMPLE_RATE) {
      const buffer = new ArrayBuffer(44 + int16View.byteLength);
      const view = new DataView(buffer);
      function writeString(off, str) { for (let i = 0; i < str.length; i++) view.setUint8(off + i, str.charCodeAt(i)); }
      let off = 0;
      writeString(off, 'RIFF'); off += 4;
      view.setUint32(off, 36 + int16View.byteLength, true); off += 4;
      writeString(off, 'WAVE'); off += 4;
      writeString(off, 'fmt '); off += 4;
      view.setUint32(off, 16, true); off += 4; // subchunk size
      view.setUint16(off, 1, true); off += 2;  // PCM
      view.setUint16(off, numChannels, true); off += 2;
      view.setUint32(off, sampleRate, true); off += 4;
      const byteRate = sampleRate * numChannels * 2;
      view.setUint32(off, byteRate, true); off += 4;
      view.setUint16(off, numChannels * 2, true); off += 2; // block align
      view.setUint16(off, 16, true); off += 2; // bits per sample
      writeString(off, 'data'); off += 4;
      view.setUint32(off, int16View.byteLength, true); off += 4;
      // data
      new Uint8Array(buffer, 44).set(new Uint8Array(int16View.buffer));
      return new Blob([view], { type: 'audio/wav' });
    }

    function appendToPcmRing(samples16k) {
      pcmRingBuffer.push(samples16k);
      const maxSamples = TARGET_SAMPLE_RATE * MAX_BUFFER_SECONDS;
      // trim from front if exceeding
      let total = 0;
      for (let i = pcmRingBuffer.length - 1; i >= 0; i--) {
        total += pcmRingBuffer[i].length;
        if (total > maxSamples) {
          pcmRingBuffer = pcmRingBuffer.slice(i + 1);
          break;
        }
      }
    }

    function getLastWindowAsWavBlob() {
      const need = TARGET_SAMPLE_RATE * WINDOW_SECONDS;
      if (pcmRingBuffer.length === 0) return null;
      let acc = [], total = 0;
      for (let i = pcmRingBuffer.length - 1; i >= 0 && total < need; i--) {
        acc.unshift(pcmRingBuffer[i]);
        total += pcmRingBuffer[i].length;
      }
      if (total === 0) return null;
      let merged = new Float32Array(total);
      let off = 0;
      acc.forEach(a => { merged.set(a, off); off += a.length; });
      if (merged.length > need) merged = merged.slice(merged.length - need);
      const int16 = floatTo16BitPCM(merged);
      return encodeWAV(int16, 1, TARGET_SAMPLE_RATE);
    }

    function getFullAsWavBlob() {
      if (!pcmFullBuffer || pcmFullBuffer.length === 0) return null;
      let total = pcmFullBuffer.reduce((sum, arr) => sum + arr.length, 0);
      let merged = new Float32Array(total);
      let off = 0;
      pcmFullBuffer.forEach(arr => { merged.set(arr, off); off += arr.length; });
      const int16 = floatTo16BitPCM(merged);
      return encodeWAV(int16, 1, TARGET_SAMPLE_RATE);
    }

    // Real-time transcription during recording
    async function sendRealtimeChunk() {
      if (recordingCancelled || isSendingRealtime) {
        console.log('üõë Recording cancelled, stopping transcription');
        return;
      }

      isSendingRealtime = true;
      try {
        // Check if we have enough chunks
        if (realtimeChunks.length === 0) {
          console.log('‚è≥ No chunks yet, waiting...');
          return;
        }

        // Build WAV from PCM ring window
        const wavBlob = getLastWindowAsWavBlob();
        if (!wavBlob) { console.log('‚è≥ No PCM window yet'); return; }
        const MAX_BYTES = 2_000_000; // ~2MB
        if (wavBlob.size > MAX_BYTES) { console.warn('üö´ WAV too large'); return; }
        console.log(`üì§ Sending WAV window (${wavBlob.size} bytes)`);

        const formData = new FormData();
        formData.append('audio_chunk', wavBlob, 'chunk.wav');

        const response = await fetch(realtimeTranscribeUrl, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // PCM ring is trimmed on append; keep realtimeChunks for UI only

        const result = await response.json();
        console.log(`üì® Server response status: ${response.status}, result:`, result);
        
        if (result.status === 'success') {
          console.log(`üîç Full server result:`, JSON.stringify(result, null, 2));
          
          if (result.transcription && result.transcription.trim()) {
            const newText = result.transcription.trim();
            console.log(`üìù Raw transcription: "${newText}" (${newText.length} chars)`);
            console.log(`üìä Previous text length: ${liveTranscriptionText.length} chars`);
            
            // Check if this appears to be speaker-formatted content
            const hasSpeakerLabels = newText.includes('Arts:') || newText.includes('Pati√´nt:');
            
            // Replacement policy:
            // - Only replace when we have speaker labels (good formatting)
            // - Otherwise keep showing the last good formatted transcript
            const isLongerOrDifferent = (newText.length > liveTranscriptionText.length) || (newText !== liveTranscriptionText);
            if (hasSpeakerLabels && isLongerOrDifferent) {
              console.log(`‚úÖ Replacing with speaker-formatted transcription: "${newText.substring(0, 100)}..."`);
              liveTranscriptionText = newText;
              lastSpeakerText = newText;
              updateLiveTranscriptionDisplay(lastSpeakerText);
            } else if (!hasSpeakerLabels) {
              console.log(`‚ö†Ô∏è No speaker labels present. Reposting last good formatted transcript.`);
              updateLiveTranscriptionDisplay(lastSpeakerText || liveTranscriptionText);
            } else {
              console.log(`üîÑ Keeping existing transcription (same or shorter)`);
              updateLiveTranscriptionDisplay(lastSpeakerText || liveTranscriptionText);
            }
          } else {
            console.log(`‚ö†Ô∏è Empty transcription - server result:`, result);
            console.log(`üìä Current text: "${liveTranscriptionText}" (${liveTranscriptionText.length} chars)`);
            // Keep existing display; if nothing yet, show listening message
            updateLiveTranscriptionDisplay(lastSpeakerText || liveTranscriptionText || 'üé§ Luister mee...');
          }
        } else if (result.status === 'skipped' || result.status === 'error') {
          console.log('‚ùå Chunk processing failed:', result);
          // Repost last good formatted transcript instead of raw/unformatted
          updateLiveTranscriptionDisplay(lastSpeakerText || liveTranscriptionText);
        }

        // UI buffer trimming (optional)
        if (realtimeChunks.length > 10) {
          realtimeChunks = realtimeChunks.slice(-10);
        }

      } catch (error) {
        console.error('Real-time transcription error:', error);
        // Don't stop recording on transcription errors - just continue
        // Repost last good formatted transcript
        updateLiveTranscriptionDisplay(lastSpeakerText || liveTranscriptionText);
      } finally {
        isSendingRealtime = false;
      }
    }

    function normalizeSpeakerBreaks(text) {
      if (!text) return text;
      // Insert a newline before speaker labels that appear mid-line
      // Pattern: any non-newline char followed by optional spaces then label
      // Keep the preceding char, then add a newline before the label
      text = text.replace(/([^\n])\s*(Arts:)/g, '$1\n\n$2');
      text = text.replace(/([^\n])\s*(Pati√´nt:)/g, '$1\n\n$2');
      return text;
    }

    function formatSpeakerText(text) {
      text = normalizeSpeakerBreaks(text);
      if (!text || !text.includes('Arts:') && !text.includes('Pati√´nt:')) {
        // No speaker labels, return as plain text
        return `<div class="live-transcript-text" style="word-wrap: break-word; white-space: pre-wrap; line-height: 1.6;">${text}</div>`;
      }
      
      // Format text with speaker styling
      return text
        .split('\n')
        .map(line => {
          line = line.trim();
          if (!line) return '<div style="height: 0.5rem;"></div>'; // Empty line spacing
          
          if (line.startsWith('Arts:')) {
            const content = line.substring(5).trim();
            return `
              <div style="margin: 1rem 0;">
                <div style="color: #1e40af; font-weight: 600; font-size: 0.95rem; margin-bottom: 0.25rem;"> Arts:</div>
                <div style="color: #1e3a8a; padding-left: 1rem; line-height: 1.5; border-left: 3px solid #3b82f6; padding-left: 0.75rem;">${content}</div>
              </div>
            `;
          } else if (line.startsWith('Pati√´nt:')) {
            const content = line.substring(9).trim();
            return `
              <div style="margin: 1rem 0;">
                <div style="color: #059669; font-weight: 600; font-size: 0.95rem; margin-bottom: 0.25rem;">Pati√´nt:</div>
                <div style="color: #065f46; padding-left: 1rem; line-height: 1.5; border-left: 3px solid #10b981; padding-left: 0.75rem;">${content}</div>
              </div>
            `;
          } else {
            // Continuation of previous speaker or unidentified
            return `<div style="color: #374151; padding-left: 1rem; line-height: 1.5; margin: 0.25rem 0;">${line}</div>`;
          }
        })
        .join('');
    }

    // Removed typing animation for live transcription for instant updates

    function updateLiveTranscriptionDisplay(text) {
      const display = document.getElementById('live-transcript-content');
      const container = document.getElementById('live-transcription-display');
      const currentTime = new Date().toLocaleTimeString();
      
      if (text && text.trim() && text.trim() !== 'üé§ Luister mee...') {
        if (text.length > 100) {
          container.classList.add('expanding');
        }
        
        const wordCount = text.split(' ').length;
        const formattedText = formatSpeakerText(text);
        display.innerHTML = `
          <div style="word-wrap: break-word;">${formattedText}</div>
          <div class="typing-indicator" style="margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(8, 145, 178, 0.2); color: #0891b2; font-size: 0.9rem;">
            <span style="animation: pulse 1.5s infinite;">‚óè Live transcriptie actief - ${wordCount} woorden</span>
            <span style="float: right; opacity: 0.7;">${currentTime}</span>
          </div>
        `;
      } else {
        container.classList.remove('expanding');
        display.innerHTML = `
          <div class="typing-indicator" style="color: #0891b2; font-size: 1.1rem;">
            <span style="animation: pulse 1.5s infinite;">üé§ Luister mee - begin met spreken...</span>
            <div style="margin-top: 4px; font-size: 0.9rem; opacity: 0.7;">${currentTime}</div>
          </div>
        `;
      }
      
      container.scrollTop = container.scrollHeight;
      setTimeout(() => {
        container.scrollTop = container.scrollHeight;
        if (container.scrollHeight > window.innerHeight * 0.5) {
          const rect = container.getBoundingClientRect();
          if (rect.bottom > window.innerHeight * 0.9) {
            container.scrollIntoView({ behavior: 'smooth', block: 'end' });
          }
        }
      }, 100);
      
      const wordCountLog = text ? text.split(' ').length : 0;
      if (wordCountLog > 0) {
        console.log(`üìä Transcriptie progress: ${wordCountLog} woorden, ${text.length} characters`);
      }
    }

    async function startRecording() {
      try {
         // Reset cancellation flag at start
         recordingCancelled = false;
         liveTranscriptionText = '';
         lastSpeakerText = '';
         
         audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
         batchChunks = [];
         realtimeChunks = [];
         
         let options;
         if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
           options = { mimeType: 'audio/webm;codecs=opus' };
         } else if (MediaRecorder.isTypeSupported('audio/webm')) {
           options = { mimeType: 'audio/webm' };
         } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
           options = { mimeType: 'audio/ogg;codecs=opus' };
         } else {
           options = {};
         }
           
         // Create separate recorders
         mediaRecorderRealtime = new MediaRecorder(audioStream, options);
         mediaRecorderBatch = new MediaRecorder(audioStream, options);

         // Realtime recorder handler
         mediaRecorderRealtime.ondataavailable = event => {
           if (event.data.size > 0 && !recordingCancelled) {
             console.log(`üéµ RT chunk: ${event.data.size} bytes (buffer: ${realtimeChunks.length + 1})`);
            realtimeChunks.push(event.data);
            // Keep only last 20 chunks in buffer immediately for consistent windowing
            const MAX_RT_CHUNKS = 10;
            if (realtimeChunks.length > MAX_RT_CHUNKS) {
              realtimeChunks = realtimeChunks.slice(-MAX_RT_CHUNKS);
            }
             const display = document.getElementById('live-transcript-content');
             if (realtimeChunks.length === 1) {
               display.innerHTML = '<div class="typing-indicator" style="color: #0891b2;">üéµ Audio gedetecteerd, transcriptie start binnenkort...</div>';
             }
           }
         };

         // Batch recorder handler
         mediaRecorderBatch.ondataavailable = event => {
           if (event.data.size > 0 && !recordingCancelled) {
             console.log(`üì¶ Batch chunk: ${event.data.size} bytes (buffer: ${batchChunks.length + 1})`);
             batchChunks.push(event.data);
           }
         };

         // Only batch recorder triggers final processing
         mediaRecorderBatch.onstop = handleRecordingStop;

         // Start both recorders
         mediaRecorderRealtime.start(2000); // frequent chunks for realtime
         mediaRecorderBatch.start(5000); // coarser chunks for memory safety
         // Setup PCM capture for WAV-based realtime + full-batch WAV
         audioContext = new (window.AudioContext || window.webkitAudioContext)();
         pcmSampleRate = audioContext.sampleRate;
         sourceNode = audioContext.createMediaStreamSource(audioStream);
         processorNode = audioContext.createScriptProcessor(4096, 1, 1);
         processorNode.onaudioprocess = (e) => {
           if (recordingCancelled) return;
           const input = e.inputBuffer.getChannelData(0);
           const down = downsampleTo16k(input, pcmSampleRate);
           appendToPcmRing(down);
           pcmFullBuffer.push(down);
         };
         sourceNode.connect(processorNode);
         processorNode.connect(audioContext.destination);
         
         // Show recording overlay
         document.getElementById('recording-overlay').classList.remove('hidden');
         document.getElementById('whisper-btn').disabled = true;
         
         // Initialize live transcription display
         updateLiveTranscriptionDisplay('');
         
         // Start real-time transcription interval - faster for immediate feedback  
         realtimeInterval = setInterval(() => {
          if (!recordingCancelled && mediaRecorderRealtime && mediaRecorderRealtime.state === 'recording') {
             console.log(`üîÑ Real-time interval tick - chunks available: ${realtimeChunks.length}`);
             sendRealtimeChunk();
           } else {
             console.log('‚èπÔ∏è Recording stopped or cancelled, stopping real-time transcription');
             if (realtimeInterval) {
               clearInterval(realtimeInterval);
               realtimeInterval = null;
             }
           }
         }, 2000); // Every 1.5 seconds for faster response
         
       } catch (error) {
         console.error('Recording error:', error);
         alert('Kon microfoon niet starten. Controleer uw browserinstellingen.');
       }
     }

    function stopRecording() {
      if (mediaRecorderRealtime && mediaRecorderRealtime.state === 'recording') {
        mediaRecorderRealtime.stop();
      }
      if (mediaRecorderBatch && mediaRecorderBatch.state === 'recording') {
        mediaRecorderBatch.stop();
      }
      
      // Stop real-time transcription
      if (realtimeInterval) {
        clearInterval(realtimeInterval);
        realtimeInterval = null;
      }
      
      document.getElementById('recording-overlay').classList.add('hidden');
      document.getElementById('whisper-btn').disabled = false;
      // Tear down PCM capture
      try {
        if (processorNode) { processorNode.disconnect(); processorNode = null; }
        if (sourceNode) { sourceNode.disconnect(); sourceNode = null; }
        if (audioContext) { audioContext.close(); audioContext = null; }
      } catch (e) {}
    }

         let recordingCancelled = false;

     function cancelRecording() {
       recordingCancelled = true; // Set flag to prevent processing
       
       if (mediaRecorderRealtime && mediaRecorderRealtime.state === 'recording') {
         mediaRecorderRealtime.stop();
       }
       if (mediaRecorderBatch && mediaRecorderBatch.state === 'recording') {
         mediaRecorderBatch.stop();
       }
       
       // Stop real-time transcription
       if (realtimeInterval) {
         clearInterval(realtimeInterval);
         realtimeInterval = null;
       }
       
      // Clear audio chunks to prevent processing
       batchChunks = [];
       realtimeChunks = [];
      liveTranscriptionText = '';
      lastSpeakerText = '';
       // Clear PCM ring and teardown
      pcmRingBuffer = [];
      pcmFullBuffer = [];
       try {
         if (processorNode) { processorNode.disconnect(); processorNode = null; }
         if (sourceNode) { sourceNode.disconnect(); sourceNode = null; }
         if (audioContext) { audioContext.close(); audioContext = null; }
       } catch (e) {}
       
       document.getElementById('recording-overlay').classList.add('hidden');
       document.getElementById('whisper-btn').disabled = false;
       
       if (audioStream) {
         audioStream.getTracks().forEach(track => track.stop());
         audioStream = null;
       }
       
       // Reset loading overlay if it's showing
       const loader = document.getElementById('loading-overlay');
       loader.style.display = 'none';
       
       console.log('Recording cancelled by user');
     }

         async function handleRecordingStop() {
       // Check if recording was cancelled
       if (recordingCancelled) {
         console.log('Recording was cancelled, skipping processing');
         recordingCancelled = false; // Reset flag
         return;
       }
       
      // Build full WAV from PCM buffer for batch
      const wavBlob = getFullAsWavBlob();
      if (!wavBlob) {
        console.log('No PCM buffer available, skipping processing');
        return;
      }
      console.log('Processing batch recording (WAV) for Azure-corrected transcription ‚Üí SOEP');
      const formData = new FormData();
      formData.append('file', wavBlob, 'recording.wav');
      
      showLoading(true);
      
      try {
        const response = await fetch(endpoints.transcribeAudio, {
          method: 'POST',
          body: formData
        });
        
        const result = await response.json();
        
        if (result.error) {
          throw new Error(result.error);
        }
        
        // Set transcribed text (Azure-corrected from backend)
        document.getElementById('text-input').value = result.transcription || '';
        
        // Auto-generate SOEP
        await generateSOEP();
        
      } catch (error) {
        console.error('Transcription error:', error);
        alert('Fout bij transcriptie. Probeer het opnieuw.');
      } finally {
        showLoading(false);
      }
         
            // Clean up
         if (audioStream) {
           audioStream.getTracks().forEach(track => track.stop());
        audioStream = null;
      }
      
      // Stop real-time transcription interval
      if (realtimeInterval) {
        clearInterval(realtimeInterval);
        realtimeInterval = null;
      }
      
      // Reset for next recording
      recordingCancelled = false;
      // Note: Don't clear liveTranscriptionText here as it's used for SOEP generation
    }

    // Utility functions
    function showLoading(show) {
      const overlay = document.getElementById('loading-overlay');
      overlay.style.display = show ? 'flex' : 'none';
    }

    // Event listeners
    document.getElementById('generate-soep').addEventListener('click', generateSOEP);
    document.getElementById('whisper-btn').addEventListener('click', startRecording);
    document.getElementById('soep-recording-btn').addEventListener('click', stopRecording);
    document.getElementById('cancel-recording-btn').addEventListener('click', cancelRecording);
    
         // Auto-expanding textarea
     const textarea = document.getElementById('text-input');
     textarea.addEventListener('input', function() {
       this.style.height = 'auto';
       this.style.height = Math.min(this.scrollHeight, 200) + 'px';
     });

          // Intelligente Live Tolk (One-button smart translation)
     let tolkRecognition = null;
     let tolkConversationHistory = [];
     let isRecording = false;

     // Initialize intelligent speech recognition
     function initializeIntelligentTolk() {
       if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
         const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
         
         tolkRecognition = new SpeechRecognition();
         tolkRecognition.continuous = false;
         tolkRecognition.interimResults = true;
         tolkRecognition.lang = 'auto'; // Will be set dynamically
         
         setupTolkRecognitionEvents();
       } else {
         console.error('Speech recognition not supported');
         alert('Spraakherkenning wordt niet ondersteund in deze browser. Gebruik Chrome voor de beste ervaring.');
       }
     }

     function setupTolkRecognitionEvents() {
       tolkRecognition.onresult = function(event) {
         let transcript = '';
         for (let i = event.resultIndex; i < event.results.length; i++) {
           transcript += event.results[i][0].transcript;
         }
         
         // Update live transcript
         document.getElementById('live-transcript').innerHTML = transcript || '<span class="text-gray-400">Gesproken woorden verschijnen hier...</span>';
         
         if (event.results[event.results.length - 1].isFinal) {
           intelligentTranslateAndSpeak(transcript);
         }
       };
       
       tolkRecognition.onstart = function() {
         updateTolkStatus('Luisteren...', 'bg-green-100 text-green-600');
         isRecording = true;
       };
       
       tolkRecognition.onend = function() {
         updateTolkStatus('Klaar om te starten', 'bg-gray-100 text-gray-600');
         isRecording = false;
       };

       tolkRecognition.onerror = function(event) {
         console.error('Speech recognition error:', event.error);
         updateTolkStatus('Fout - probeer opnieuw', 'bg-red-100 text-red-600');
         isRecording = false;
       };
     }

     function updateTolkStatus(text, className) {
       const statusEl = document.getElementById('tolk-status');
       statusEl.textContent = text;
       statusEl.className = `px-4 py-2 rounded-full text-sm inline-block mb-4 ${className}`;
     }

     async function intelligentTranslateAndSpeak(spokenText) {
       updateTolkStatus('AI analyseert...', 'bg-yellow-100 text-yellow-600');
       
       try {
         const language1 = document.getElementById('language-1').value;
         const language2 = document.getElementById('language-2').value;
         
        // Send to AI for intelligent language detection and translation
        const response = await fetch(endpoints.intelligentTranslate, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
           },
           body: JSON.stringify({
             spoken_text: spokenText,
             language_1: language1,
             language_2: language2
           })
         });
         
         const data = await response.json();
         
         if (data.error) {
           throw new Error(data.error);
         }
         
         // Display results in Dutch
         const translationOutput = document.getElementById('translation-output');
         translationOutput.innerHTML = `
           <div class="mb-3">
             <p class="text-sm text-blue-600 font-medium">Gedetecteerde taal: ${data.detected_language_name}</p>
             <p class="text-sm text-blue-600">Vertaald naar: ${data.target_language_name}</p>
           </div>
           <div class="text-blue-800 font-medium">${data.translation}</div>
         `;
         
         // Speak the translation
         speakTranslation(data.translation, data.target_language);
         
         // Add to conversation history
         addToTolkHistory(spokenText, data.translation, data.detected_language_name, data.target_language_name);
         
         updateTolkStatus('Vertaling voltooid', 'bg-green-100 text-green-600');
         
         // Reset status after 2 seconds
         setTimeout(() => {
           updateTolkStatus('Klaar om te starten', 'bg-gray-100 text-gray-600');
         }, 2000);
         
       } catch (error) {
         console.error('Intelligent translation error:', error);
         updateTolkStatus('Vertaling mislukt', 'bg-red-100 text-red-600');
         
         const translationOutput = document.getElementById('translation-output');
         translationOutput.innerHTML = '<span class="text-red-600">Er is een fout opgetreden bij de vertaling. Probeer het opnieuw.</span>';
         
         setTimeout(() => {
           updateTolkStatus('Klaar om te starten', 'bg-gray-100 text-gray-600');
         }, 3000);
       }
     }

     function speakTranslation(text, languageCode) {
       if ('speechSynthesis' in window) {
         const utterance = new SpeechSynthesisUtterance(text);
         utterance.lang = languageCode;
         utterance.rate = 0.9;
         utterance.pitch = 1;
         
         // Find voice for the language
         const voices = speechSynthesis.getVoices();
         const voice = voices.find(v => v.lang.startsWith(languageCode));
         if (voice) {
           utterance.voice = voice;
         }
         
         speechSynthesis.speak(utterance);
       }
     }

     function addToTolkHistory(original, translation, fromLang, toLang) {
       const historyItem = {
         timestamp: new Date(),
         original: original,
         translation: translation,
         fromLanguage: fromLang,
         toLanguage: toLang
       };
       
       tolkConversationHistory.push(historyItem);
       updateTolkConversationDisplay();
     }

     function updateTolkConversationDisplay() {
       const historyEl = document.getElementById('tolk-conversation-history');
       
       if (tolkConversationHistory.length === 0) {
         historyEl.innerHTML = '<div class="text-gray-500 text-center py-8">Gesprek geschiedenis verschijnt hier...</div>';
         return;
       }
       
       historyEl.innerHTML = tolkConversationHistory.map((item, index) => `
         <div class="border-l-4 border-blue-500 bg-blue-50 p-4 rounded-r-lg">
           <div class="flex justify-between items-start mb-2">
             <span class="font-medium text-blue-900">
               Gesprek ${index + 1} (${item.fromLanguage} ‚Üí ${item.toLanguage})
             </span>
             <span class="text-xs text-gray-500">${item.timestamp.toLocaleTimeString()}</span>
           </div>
           <div class="text-sm text-gray-700 mb-1"><strong>Origineel (${item.fromLanguage}):</strong> ${item.original}</div>
           <div class="text-sm text-gray-600"><strong>Vertaling (${item.toLanguage}):</strong> ${item.translation}</div>
         </div>
       `).join('');
       
       historyEl.scrollTop = historyEl.scrollHeight;
     }

     // Live conversation gets cleared automatically when session ends
     // No manual clear/export functions needed for live translator

     // Language name mappings
     const languageNames = {
       'nl': 'Nederlands',
       'en': 'English',
       'ar': 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©',
       'tr': 'T√ºrk√ße',
       'pl': 'Polski',
       'es': 'Espa√±ol',
       'fr': 'Fran√ßais',
       'de': 'Deutsch',
       'it': 'Italiano',
       'pt': 'Portugu√™s',
       'ru': '–†—É—Å—Å–∫–∏–π',
       'zh': '‰∏≠Êñá',
       'hi': '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä',
       'ur': 'ÿßÿ±ÿØŸà'
     };

     // Update language displays
     function updateLanguageDisplays() {
       const lang1 = document.getElementById('language-1')?.value || 'nl';
       const lang2 = document.getElementById('language-2')?.value || 'en';
       
       const doctorDisplay = document.getElementById('doctor-lang-display');
       const patientDisplay = document.getElementById('patient-lang-display');
       
       if (doctorDisplay) {
         doctorDisplay.textContent = `(${languageNames[lang1] || lang1})`;
       }
       if (patientDisplay) {
         patientDisplay.textContent = `(${languageNames[lang2] || lang2})`;
       }
     }

     // Initialize intelligent tolk when page loads
     document.addEventListener('DOMContentLoaded', function() {
       initializeIntelligentTolk();
       
       // Update language displays when selections change
       const lang1Select = document.getElementById('language-1');
       const lang2Select = document.getElementById('language-2');
       
       if (lang1Select) {
         lang1Select.addEventListener('change', updateLanguageDisplays);
       }
       if (lang2Select) {
         lang2Select.addEventListener('change', updateLanguageDisplays);
       }
       
       // Initial update
       updateLanguageDisplays();
       
       // Single record button event listeners
       const tolkBtn = document.getElementById('tolk-record-btn');
       
       if (tolkBtn) {
         // Mouse events
         tolkBtn.addEventListener('mousedown', function() {
           if (tolkRecognition && !isRecording) {
             tolkRecognition.start();
           }
         });
         
         tolkBtn.addEventListener('mouseup', function() {
           if (tolkRecognition && isRecording) {
             tolkRecognition.stop();
           }
         });
         
         // Touch events for mobile
         tolkBtn.addEventListener('touchstart', function(e) {
           e.preventDefault();
           if (tolkRecognition && !isRecording) {
             tolkRecognition.start();
           }
         });
         
         tolkBtn.addEventListener('touchend', function(e) {
           e.preventDefault();
           if (tolkRecognition && isRecording) {
             tolkRecognition.stop();
           }
         });

         // Prevent context menu on long press
         tolkBtn.addEventListener('contextmenu', function(e) {
           e.preventDefault();
         });
       }
    });
  </script>
</body>
</html>
